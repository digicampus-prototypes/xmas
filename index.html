<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Digicampus Holiday Pixel Art</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            /* Deep GovTech dark */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>

    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let particles = [];
        let snowParticles = [];
        let width, height;

        // Configuration
        const config = {
            text: "Digicampus",
            color: '#00F0FF', // Tech Blue
            pixelSize: 4,     // Size of the 'pixels'
            gap: 5,           // Spacing for sampling (create the grid look)
            mouseRadius: 50,
            textBaseY: 0
        };

        // Mouse interaction
        const mouse = { x: null, y: null };
        window.addEventListener('mousemove', (e) => {
            mouse.x = e.x;
            mouse.y = e.y;
        });

        // 1. Class for the Text Pixels
        class Particle {
            constructor(x, y, color) {
                this.x = Math.random() * width; // Start scattered
                this.y = Math.random() * height;
                this.originX = x;
                this.originY = y;
                this.color = color;
                this.size = config.pixelSize;
                this.vx = 0;
                this.vy = 0;
                this.friction = 0.90;
                this.ease = 0.15;
                this.dx = 0;
                this.dy = 0;
                this.distance = 0;
                this.force = 0;
                this.angle = 0;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
            }

            update() {
                // physics to return to origin
                this.dx = mouse.x - this.x;
                this.dy = mouse.y - this.y;
                this.distance = Math.sqrt(this.dx * this.dx + this.dy * this.dy);

                // Mouse interaction (repel)
                if (this.distance < config.mouseRadius) {
                    this.force = -config.mouseRadius / this.distance;
                    this.angle = Math.atan2(this.dy, this.dx);
                    this.vx += this.force * Math.cos(this.angle) * 2;
                    this.vy += this.force * Math.sin(this.angle) * 2;
                }

                // Return to home position (Homeostasis)
                this.x += (this.originX - this.x) * this.ease;
                this.y += (this.originY - this.y) * this.ease;

                // Add velocity
                this.x += this.vx;
                this.y += this.vy;

                // Friction
                this.vx *= this.friction;
                this.vy *= this.friction; // slightly less friction for floaty feel

                // Slight organic shimmer
                if (Math.random() > 0.98) {
                    this.x += (Math.random() - 0.5) * 2;
                }

                this.draw();
            }
        }

        // 2. Class for Snow
        class Snow {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height - height;
                this.size = Math.random() * 3 + 1;
                this.speed = Math.random() * 2 + 0.5;
                this.drift = (Math.random() - 0.5) * 0.5;
            }

            update() {
                this.y += this.speed;
                this.x += this.drift;

                if (this.y > height) {
                    this.reset();
                }

                ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
                ctx.fillRect(this.x, this.y, this.size, this.size); // Square snow for pixel theme
            }
        }

        function init() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            particles = [];
            snowParticles = [];

            // Setup Snow
            for (let i = 0; i < 150; i++) {
                snowParticles.push(new Snow());
            }

            // Setup Text Scan
            // We draw text to an offscreen position, scan the pixels, then clear it.
            ctx.fillStyle = 'white';
            const fontSize = Math.min(width / 8, 150); // Responsive font size
            ctx.font = `900 ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            config.textBaseY = height / 2;

            // Draw standard text to scan
            ctx.fillText(config.text, width / 2, config.textBaseY);

            // Scan the canvas
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            ctx.clearRect(0, 0, width, height); // Clean up

            // Iterate through pixel data
            for (let y = 0; y < height; y += config.gap) {
                for (let x = 0; x < width; x += config.gap) {
                    const index = (y * width + x) * 4;
                    const alpha = data[index + 3];

                    if (alpha > 128) {
                        particles.push(new Particle(x, y, config.color));
                    }
                }
            }

            // Manually Add the Hat pixels relative to the 'D'
            // We estimate the position of the first letter
            const textWidth = ctx.measureText(config.text).width;
            const startX = (width / 2) - (textWidth / 2);
            const hatBaseX = startX + (fontSize * 0.1); // Shift slightly right on the D
            const hatBaseY = config.textBaseY - (fontSize * 0.35); // Top of the D

            addHatPixels(hatBaseX, hatBaseY, fontSize);
        }

        function addHatPixels(bx, by, size) {
            const pixelScale = config.gap;

            // Simple Hat Map (1 = Red, 2 = White)
            const hatMap = [
                [0, 0, 0, 2, 0, 0, 0, 0],
                [0, 0, 2, 1, 2, 0, 0, 0], // Pom-pom
                [0, 0, 0, 1, 1, 0, 0, 0],
                [0, 0, 0, 1, 1, 1, 0, 0],
                [0, 0, 1, 1, 1, 1, 0, 0],
                [0, 1, 1, 1, 1, 1, 0, 0],
                [2, 2, 2, 2, 2, 2, 2, 2], // Brim
                [2, 2, 2, 2, 2, 2, 2, 2]
            ];

            const scale = size / 200; // Scale hat based on font size

            for (let r = 0; r < hatMap.length; r++) {
                for (let c = 0; c < hatMap[r].length; c++) {
                    const val = hatMap[r][c];
                    if (val !== 0) {
                        const pX = bx + (c * config.gap * 2);
                        const pY = by - (hatMap.length * config.gap * 2) + (r * config.gap * 2);

                        const color = val === 1 ? '#FF2244' : '#FFFFFF';
                        // Add a cluster of 4 pixels to make it chunky
                        particles.push(new Particle(pX, pY, color));
                        particles.push(new Particle(pX + config.gap, pY, color));
                        particles.push(new Particle(pX, pY + config.gap, color));
                        particles.push(new Particle(pX + config.gap, pY + config.gap, color));
                    }
                }
            }
        }

        function animate() {
            // Create trails for "tech" feel
            ctx.fillStyle = 'rgba(5, 5, 16, 0.4)';
            ctx.fillRect(0, 0, width, height);

            // Update Snow
            snowParticles.forEach(snow => snow.update());

            // Update Text
            particles.forEach(p => p.update());

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', init);

        // Start
        init();
        animate();

    </script>
</body>

</html>