<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- crucial for mobile -->
    <title>Digicampus Winter Wish</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510; /* Deep GovTech dark */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
            color: #00F0FF;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        /* UI Layer for Input and Wish */
        #ui-layer {
            position: relative;
            z-index: 10;
            text-align: center;
            width: 100%;
            max-width: 600px;
            padding: 20px;
        }

        /* Input Container */
        #input-container {
            background: rgba(5, 5, 16, 0.9);
            border: 1px solid #00F0FF;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.2);
            transition: opacity 0.5s ease;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 20px;
            color: white;
            font-weight: normal;
        }

        input[type="text"] {
            background: transparent;
            border: none;
            border-bottom: 2px solid #00F0FF;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            font-size: 20px;
            padding: 10px;
            text-align: center;
            width: 80%;
            margin-bottom: 30px;
            outline: none;
        }

        input[type="text"]::placeholder {
            color: rgba(255, 255, 255, 0.3);
        }

        button {
            background: #00F0FF;
            color: #050510;
            border: none;
            padding: 12px 30px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        button:hover {
            background: white;
            box-shadow: 0 0 15px #00F0FF;
        }

        /* The Wish Display */
        #wish-display {
            display: none; /* Hidden initially */
            margin-top: 30vh; /* Push it down below the canvas text */
            font-size: 18px;
            line-height: 1.6;
            color: white;
            text-shadow: 0 0 5px rgba(0, 240, 255, 0.5);
            pointer-events: none; /* Let clicks pass through to canvas */
            opacity: 0;
            transition: opacity 2s ease;
            padding: 0 20px;
        }

        .highlight {
            color: #00F0FF;
            font-weight: bold;
        }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>

<div id="ui-layer">
    <!-- Input Section -->
    <div id="input-container">
        <h1>Welcome to Digicampus</h1>
        <input type="text" id="nameInput" placeholder="Enter your name" autocomplete="off">
        <br>
        <button onclick="revealWish()">Unlock Winter Wish</button>
    </div>

    <!-- Wish Section -->
    <div id="wish-display"></div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const uiLayer = document.getElementById('ui-layer');
    const inputContainer = document.getElementById('input-container');
    const wishDisplay = document.getElementById('wish-display');

    let particles = [];
    let snowParticles = [];
    let width, height;
    
    // Pool of 20 Personal-ish Winter Wishes
    const wishes = [
        "Wishing you a season of recharging your biological batteries, {name}.",
        "{name}, may your code be bug-free and your holidays stress-free.",
        "Hereâ€™s to a new year of breakthrough insights and zero merge conflicts, {name}.",
        "{name}, may your 2026 be as resilient and dynamic as a distributed network.",
        "Wishing you connection, collaboration, and calm this winter, {name}.",
        "{name}, may you find time to slow down and engineer some happiness this season.",
        "Wishing you a prosperous new year with high uptime and low stress, {name}.",
        "May your holidays be as bright as a well-optimized display, {name}.",
        "{name}, sending you data-driven proof that you deserve a great break.",
        "Wishing you a season of innovation and warm connections, {name}.",
        "{name}, may your days be merry and your systems secure.",
        "Hereâ€™s to unhurried moments and future-proof memories, {name}.",
        "Wishing you clarity, purpose, and peace in the new year, {name}.",
        "{name}, take this time to debug your mind and refresh your spirit.",
        "May the new year bring you impactful projects and joyful pauses, {name}.",
        "Wishing you a holiday season with optimal throughput of joy, {name}.",
        "{name}, may your bandwidth for happiness be unlimited this year.",
        "Hereâ€™s to smart solutions and warm traditions, {name}.",
        "Wishing you a sustainable and scalable year of success, {name}.",
        "{name}, may you upgrade your downtime this holiday season."
    ];

    // Configuration
    const config = {
        text: "Digicampus",
        color: '#00F0FF', // Tech Blue
        pixelSize: 4,     // Size of the 'pixels'
        gap: 5,           // Spacing for sampling (create the grid look)
        mouseRadius: 50,
        textBaseY: 0
    };

    // Mouse interaction
    const mouse = { x: null, y: null };
    window.addEventListener('mousemove', (e) => {
        mouse.x = e.x;
        mouse.y = e.y;
    });
    
    // Also handle touch for mobile
    window.addEventListener('touchmove', (e) => {
        mouse.x = e.touches[0].clientX;
        mouse.y = e.touches[0].clientY;
    });

    // --- RICKROLL BYTEBEAT LOGIC ---
    const musicParse = function(f) {
        // This generates a WAV file string from the formula
        return eval("for(var t=0,S='RIFF_oO_WAVEfmt " + atob('EAAAAAEAAQBAHwAAQB8AAAEACAA') + "data';++t<3e5;)S+=String.fromCharCode(" + f + ")");
    };

    const playLowFiRickroll = function() {
        const formula = '(t<<3)*[8/9,1,9/8,6/5,4/3,3/2,0][[0xd2d2c8,0xce4088,0xca32c8,0x8e4009][t>>14&3]>>(0x3dbe4688>>((t>>10&15)>9?18:t>>10&15)*3&7)*3&7]&255';
        const audio = new Audio("data:audio/wav;base64," + (btoa(musicParse(formula))));
        audio.play();
    };

    // --- UI LOGIC ---
    function revealWish() {
        const nameInput = document.getElementById('nameInput');
        let name = nameInput.value.trim();
        
        if (!name) name = "Friend"; // Fallback if empty

        // 1. Hide Input
        inputContainer.style.opacity = '0';
        setTimeout(() => {
            inputContainer.style.display = 'none';

            // 1 in 21 Chance of a Rickroll (Audio)
            // We do this check AFTER hiding the input so the user sees the change
            if (Math.floor(Math.random() * 20) === 0) {
                 playLowFiRickroll();
                 wishDisplay.innerHTML = "Never gonna give you up this Christmas! ðŸŽµ";
                 wishDisplay.style.display = 'block';
                 wishDisplay.style.opacity = '1';
                 return;
            }

            // Normal Wish Logic
            const randomIndex = Math.floor(Math.random() * wishes.length);
            let selectedWish = wishes[randomIndex];
            selectedWish = selectedWish.replace("{name}", `<span class="highlight">${name}</span>`);

            wishDisplay.innerHTML = selectedWish;
            wishDisplay.style.display = 'block';
            
            // Small delay for drama before fading in
            setTimeout(() => {
                wishDisplay.style.opacity = '1';
            }, 100);

        }, 500);
    }


    // --- CANVAS LOGIC ---

    class Particle {
        constructor(x, y, color) {
            this.x = Math.random() * width; // Start scattered
            this.y = Math.random() * height;
            this.originX = x;
            this.originY = y;
            this.color = color;
            this.size = config.pixelSize;
            this.vx = 0;
            this.vy = 0;
            this.friction = 0.90;
            this.ease = 0.15;
            this.dx = 0;
            this.dy = 0;
            this.distance = 0;
            this.force = 0;
            this.angle = 0;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.size, this.size);
        }

        update() {
            // physics to return to origin
            this.dx = mouse.x - this.x;
            this.dy = mouse.y - this.y;
            this.distance = Math.sqrt(this.dx * this.dx + this.dy * this.dy);
            
            // Mouse interaction (repel)
            if (this.distance < config.mouseRadius) {
                this.force = -config.mouseRadius / this.distance;
                this.angle = Math.atan2(this.dy, this.dx);
                this.vx += this.force * Math.cos(this.angle) * 2;
                this.vy += this.force * Math.sin(this.angle) * 2;
            }

            // Return to home position (Homeostasis)
            this.x += (this.originX - this.x) * this.ease;
            this.y += (this.originY - this.y) * this.ease;

            // Add velocity
            this.x += this.vx;
            this.y += this.vy;

            // Friction
            this.vx *= this.friction;
            this.vy *= this.friction; 

            // Slight organic shimmer
            if (Math.random() > 0.98) {
                this.x += (Math.random() - 0.5) * 2;
            }

            this.draw();
        }
    }

    class Snow {
        constructor() {
            this.reset();
        }
        
        reset() {
            this.x = Math.random() * width;
            this.y = Math.random() * height - height;
            this.size = Math.random() * 3 + 1;
            this.speed = Math.random() * 2 + 0.5;
            this.drift = (Math.random() - 0.5) * 0.5;
        }

        update() {
            this.y += this.speed;
            this.x += this.drift;

            if (this.y > height) {
                this.reset();
            }
            
            ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
            ctx.fillRect(this.x, this.y, this.size, this.size);
        }
    }

    function init() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        
        // Fix for IndexSizeError: Safety check for zero dimensions
        if (width <= 0 || height <= 0) return;

        particles = [];
        snowParticles = [];

        // Setup Snow
        for(let i = 0; i < 150; i++) {
            snowParticles.push(new Snow());
        }

        // Setup Text Scan
        ctx.fillStyle = 'white';
        // Responsive font: slightly smaller to ensure fit on mobile
        const fontSize = Math.min(width / 8, 120); 
        ctx.font = `900 ${fontSize}px Arial`; 
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Move text UP slightly to make room for the wish below
        config.textBaseY = height * 0.4; 
        
        // Draw standard text to scan
        ctx.fillText(config.text, width / 2, config.textBaseY);
        
        // Scan the canvas
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        ctx.clearRect(0, 0, width, height); 

        // Iterate through pixel data
        for (let y = 0; y < height; y += config.gap) {
            for (let x = 0; x < width; x += config.gap) {
                const index = (y * width + x) * 4;
                const alpha = data[index + 3];

                if (alpha > 128) {
                    particles.push(new Particle(x, y, config.color));
                }
            }
        }

        // Add Hat
        const textWidth = ctx.measureText(config.text).width;
        const startX = (width / 2) - (textWidth / 2);
        const hatBaseX = startX + (fontSize * 0.1); 
        const hatBaseY = config.textBaseY - (fontSize * 0.35); 

        addHatPixels(hatBaseX, hatBaseY, fontSize);
    }

    function addHatPixels(bx, by, size) {
        const hatMap = [
            [0,0,0,2,0,0,0,0],
            [0,0,2,1,2,0,0,0],
            [0,0,0,1,1,0,0,0],
            [0,0,0,1,1,1,0,0],
            [0,0,1,1,1,1,0,0],
            [0,1,1,1,1,1,0,0],
            [2,2,2,2,2,2,2,2],
            [2,2,2,2,2,2,2,2]
        ];

        for(let r=0; r<hatMap.length; r++) {
            for(let c=0; c<hatMap[r].length; c++) {
                const val = hatMap[r][c];
                if(val !== 0) {
                    const pX = bx + (c * config.gap * 2); 
                    const pY = by - (hatMap.length * config.gap * 2) + (r * config.gap * 2);
                    
                    const color = val === 1 ? '#FF2244' : '#FFFFFF';
                    // Cluster for chunkiness
                    particles.push(new Particle(pX, pY, color));
                    particles.push(new Particle(pX+config.gap, pY, color));
                    particles.push(new Particle(pX, pY+config.gap, color));
                    particles.push(new Particle(pX+config.gap, pY+config.gap, color));
                }
            }
        }
    }

    function animate() {
        ctx.fillStyle = 'rgba(5, 5, 16, 0.4)'; 
        ctx.fillRect(0, 0, width, height);

        snowParticles.forEach(snow => snow.update());
        particles.forEach(p => p.update());

        requestAnimationFrame(animate);
    }

    window.addEventListener('resize', init);
    
    // Start
    init();
    animate();

</script>
</body>
</html>
